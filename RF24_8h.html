<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Fraise: /home/arsene/pd-externals/Fraise/RF24/RF24.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-Fraise.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fraise
   &#160;<span id="projectnumber">2.1</span>
   </div>
   <div id="projectbrief">FRAmework for Interfacing Software and Electronics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('RF24_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RF24.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="fruit_8h_source.html">fruit.h</a>&gt;</code><br />
</div>
<p><a href="RF24_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58f5e1a21ee319e8535fe2b4737fa7b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a58f5e1a21ee319e8535fe2b4737fa7b3">RF24_init</a> ()</td></tr>
<tr class="separator:a58f5e1a21ee319e8535fe2b4737fa7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13df844e485b64af029be27bff5bdf3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a13df844e485b64af029be27bff5bdf3f">RF24_isChipConnected</a> ()</td></tr>
<tr class="separator:a13df844e485b64af029be27bff5bdf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795bb1fededae3d5e3d074653c662619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a795bb1fededae3d5e3d074653c662619">RF24_startListening</a> (void)</td></tr>
<tr class="separator:a795bb1fededae3d5e3d074653c662619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d9a6c41ffb1a516657b60c4e27602a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a42d9a6c41ffb1a516657b60c4e27602a">RF24_stopListening</a> (void)</td></tr>
<tr class="separator:a42d9a6c41ffb1a516657b60c4e27602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e998916ce8974bbf027bf8630ed756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a52e998916ce8974bbf027bf8630ed756">RF24_available</a> (void)</td></tr>
<tr class="separator:a52e998916ce8974bbf027bf8630ed756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee4d1091e2f5c8c5b434c24aa2a2d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a11ee4d1091e2f5c8c5b434c24aa2a2d8">RF24_read</a> (void *buf, unsigned char len)</td></tr>
<tr class="separator:a11ee4d1091e2f5c8c5b434c24aa2a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d0a85f8f880cf821b953f93fef09d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a31d0a85f8f880cf821b953f93fef09d8">RF24_openWritingPipe</a> (const uint8_t *address)</td></tr>
<tr class="separator:a31d0a85f8f880cf821b953f93fef09d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ce99b2d6f1511eec7806516101428a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aa6ce99b2d6f1511eec7806516101428a">RF24_openReadingPipe</a> (uint8_t number, const uint8_t *address)</td></tr>
<tr class="separator:aa6ce99b2d6f1511eec7806516101428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Operation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods you can use to drive the chip in more advanced ways </p>
</div></td></tr>
<tr class="memitem:aa18075c80995cad33e4b829169613cf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aa18075c80995cad33e4b829169613cf0">RF24_pipeAvailable</a> (uint8_t *pipe_num)</td></tr>
<tr class="separator:aa18075c80995cad33e4b829169613cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d3f2e63e369890353fecdb42d28957"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a29d3f2e63e369890353fecdb42d28957">RF24_rxFifoFull</a> ()</td></tr>
<tr class="separator:a29d3f2e63e369890353fecdb42d28957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c1293a8ada1114bed1a76c9a044244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a27c1293a8ada1114bed1a76c9a044244">RF24_powerDown</a> (void)</td></tr>
<tr class="separator:a27c1293a8ada1114bed1a76c9a044244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8228aa8163d5b7103f6bd70da3a67612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a8228aa8163d5b7103f6bd70da3a67612">RF24_powerUp</a> (void)</td></tr>
<tr class="separator:a8228aa8163d5b7103f6bd70da3a67612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6badb9c1062591a6b89171c7116571be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a6badb9c1062591a6b89171c7116571be">RF24_write</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:a6badb9c1062591a6b89171c7116571be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3502954f448fb04e566bd727b32c4eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#ac3502954f448fb04e566bd727b32c4eb">RF24_txStandBy</a> ()</td></tr>
<tr class="separator:ac3502954f448fb04e566bd727b32c4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68e730561ea861392e55329049a6a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aa68e730561ea861392e55329049a6a41">RF24_writeAckPayload</a> (uint8_t pipe, const void *buf, uint8_t len)</td></tr>
<tr class="separator:aa68e730561ea861392e55329049a6a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a75b9a7259269b5e5545c5ae9cbf10d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a9a75b9a7259269b5e5545c5ae9cbf10d">RF24_isAckPayloadAvailable</a> (void)</td></tr>
<tr class="separator:a9a75b9a7259269b5e5545c5ae9cbf10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aad17af719b63e7f80915de9ab5288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a36aad17af719b63e7f80915de9ab5288">RF24_whatHappened</a> (bool *tx_ok, bool *tx_fail, bool *rx_ready)</td></tr>
<tr class="separator:a36aad17af719b63e7f80915de9ab5288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e6af287baedc4fe1d40e6fc0716d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a58e6af287baedc4fe1d40e6fc0716d6b">RF24_reUseTX</a> ()</td></tr>
<tr class="separator:a58e6af287baedc4fe1d40e6fc0716d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12f4bcb9908f2d4efa0006145ba8691"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#ad12f4bcb9908f2d4efa0006145ba8691">RF24_testCarrier</a> (void)</td></tr>
<tr class="separator:ad12f4bcb9908f2d4efa0006145ba8691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad192ea1a3a815e1ef84fab39fa187618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#ad192ea1a3a815e1ef84fab39fa187618">RF24_testRPD</a> (void)</td></tr>
<tr class="separator:ad192ea1a3a815e1ef84fab39fa187618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22baad441994f4ebc04d22f9a3a2900d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a22baad441994f4ebc04d22f9a3a2900d">RF24_closeReadingPipe</a> (uint8_t pipe)</td></tr>
<tr class="separator:a22baad441994f4ebc04d22f9a3a2900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Optional Configurators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe1a83b99ec8153e5baf680edeeed1586"></a>If a failure has been detected, it usually indicates a hardware issue. By default the library will cease operation when a failure is detected. This should allow advanced users to detect and resolve intermittent hardware issues.</p>
<p>In most cases, the radio must be re-enabled via radio.begin(); and the appropriate settings applied after a failure occurs, if wanting to re-enable the device immediately.</p>
<p>The three main failure modes of the radio include:</p>
<p>Writing to radio: Radio unresponsive - Fixed internally by adding a timeout to the internal write functions in RF24 (failure handling)</p>
<p>Reading from radio: Available returns true always - Fixed by adding a timeout to available functions by the user. This is implemented internally in RF24Network.</p>
<p>Radio configuration settings are lost - Fixed by monitoring a value that is different from the default, and re-configuring the radio if this setting reverts to the default.</p>
<p>See the included example, GettingStarted_HandlingFailures</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.failureDetected){ </div><div class="line">  radio.begin();                       <span class="comment">// Attempt to re-configure the radio with defaults</span></div><div class="line">  radio.failureDetected = 0;           <span class="comment">// Reset the detection value</span></div><div class="line">  radio.openWritingPipe(addresses[1]); <span class="comment">// Re-configure pipe addresses</span></div><div class="line">  radio.openReadingPipe(1,addresses[0]);</div><div class="line">  report_failure();                    <span class="comment">// Blink leds, send a message, etc. to indicate failure</span></div><div class="line">}</div></div><!-- fragment --><p>Methods you can use to get or set the configuration of the chip. None are required. Calling begin() sets up a reasonable set of defaults. </p>
</td></tr>
<tr class="memitem:a28971efbe44f8b4dd531452cf696b8e9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a28971efbe44f8b4dd531452cf696b8e9">RF24_txDelay</a></td></tr>
<tr class="separator:a28971efbe44f8b4dd531452cf696b8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a484c40aa7004084ac2b6e864353004"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a3a484c40aa7004084ac2b6e864353004">RF24_csDelay</a></td></tr>
<tr class="separator:a3a484c40aa7004084ac2b6e864353004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef73522f85ff08814c701fce0b769ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aef73522f85ff08814c701fce0b769ead">RF24_setAddressWidth</a> (uint8_t a_width)</td></tr>
<tr class="separator:aef73522f85ff08814c701fce0b769ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba46e0c06d591e3e8fbe77bb30d7b65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aba46e0c06d591e3e8fbe77bb30d7b65d">RF24_setRetries</a> (uint8_t delay, uint8_t count)</td></tr>
<tr class="separator:aba46e0c06d591e3e8fbe77bb30d7b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6934d62a152b8bf2ebc514ee2ec0ef92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a6934d62a152b8bf2ebc514ee2ec0ef92">RF24_setChannel</a> (uint8_t channel)</td></tr>
<tr class="separator:a6934d62a152b8bf2ebc514ee2ec0ef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa410f56bce0094054cb2bb2f001bc099"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aa410f56bce0094054cb2bb2f001bc099">RF24_getChannel</a> (void)</td></tr>
<tr class="separator:aa410f56bce0094054cb2bb2f001bc099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d3765c21a8f230a379519edfe38aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a7a8d3765c21a8f230a379519edfe38aa">RF24_setPayloadSize</a> (uint8_t size)</td></tr>
<tr class="separator:a7a8d3765c21a8f230a379519edfe38aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d310dca584ade306b224bd417a96bbb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a8d310dca584ade306b224bd417a96bbb">RF24_getPayloadSize</a> (void)</td></tr>
<tr class="separator:a8d310dca584ade306b224bd417a96bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10df0046045b306fda76be78c2e5587a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a10df0046045b306fda76be78c2e5587a">RF24_getDynamicPayloadSize</a> (void)</td></tr>
<tr class="separator:a10df0046045b306fda76be78c2e5587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063ad3e74355a8754baa6ffc8fd74945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a063ad3e74355a8754baa6ffc8fd74945">RF24_enableAckPayload</a> (void)</td></tr>
<tr class="separator:a063ad3e74355a8754baa6ffc8fd74945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546ea8db1d399bfcc14fa11d6d6dd377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a546ea8db1d399bfcc14fa11d6d6dd377">RF24_enableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a546ea8db1d399bfcc14fa11d6d6dd377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a509aba162cff1b2acf6d54753dc76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a0a509aba162cff1b2acf6d54753dc76b">RF24_disableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a0a509aba162cff1b2acf6d54753dc76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659b73ab3294bff2c24b37a1f29b596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a3659b73ab3294bff2c24b37a1f29b596">RF24_enableDynamicAck</a> ()</td></tr>
<tr class="separator:a3659b73ab3294bff2c24b37a1f29b596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9827d1b46e839e7df625b8697bb5c58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#ad9827d1b46e839e7df625b8697bb5c58">RF24_isPVariant</a> (void)</td></tr>
<tr class="separator:ad9827d1b46e839e7df625b8697bb5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6181642ecced9289f503dcd4d2e0b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#aa6181642ecced9289f503dcd4d2e0b85">RF24_setAutoAck</a> (bool enable)</td></tr>
<tr class="separator:aa6181642ecced9289f503dcd4d2e0b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72a473f7fb7143b1805bbf08c2632d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a3a72a473f7fb7143b1805bbf08c2632d">RF24_setAutoAckPipe</a> (uint8_t pipe, bool enable)</td></tr>
<tr class="separator:a3a72a473f7fb7143b1805bbf08c2632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761beff12476b6dd967fe3128fdd5712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a761beff12476b6dd967fe3128fdd5712">RF24_setPALevel</a> (uint8_t level)</td></tr>
<tr class="separator:a761beff12476b6dd967fe3128fdd5712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf354b84f44639e21c996ff503128597"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#acf354b84f44639e21c996ff503128597">RF24_getPALevel</a> (void)</td></tr>
<tr class="separator:acf354b84f44639e21c996ff503128597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a22d56451708fd802ea27de976b2df2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a6a22d56451708fd802ea27de976b2df2">RF24_setDataRate</a> (<a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> speed)</td></tr>
<tr class="separator:a6a22d56451708fd802ea27de976b2df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff172256352b2208faa7a0d71dab27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a4ff172256352b2208faa7a0d71dab27e">RF24_getDataRate</a> (void)</td></tr>
<tr class="separator:a4ff172256352b2208faa7a0d71dab27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6338ec425b7f684915cd37488f3e5e61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a6338ec425b7f684915cd37488f3e5e61">RF24_setCRCLength</a> (<a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> length)</td></tr>
<tr class="separator:a6338ec425b7f684915cd37488f3e5e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34895106ece40c91131e95c654f821d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#ad34895106ece40c91131e95c654f821d">RF24_getCRCLength</a> (void)</td></tr>
<tr class="separator:ad34895106ece40c91131e95c654f821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0320af6c6bda86532f5654ef9e29f23d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#a0320af6c6bda86532f5654ef9e29f23d">RF24_disableCRC</a> (void)</td></tr>
<tr class="separator:a0320af6c6bda86532f5654ef9e29f23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc6f30fd9aea9bc9e7ee60fbdd07280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RF24_8h.html#afcc6f30fd9aea9bc9e7ee60fbdd07280">RF24_maskIRQ</a> (bool tx_ok, bool tx_fail, bool rx_ready)</td></tr>
<tr class="separator:afcc6f30fd9aea9bc9e7ee60fbdd07280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ebcd10ed5968038dfa8907e5984f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6ebcd10ed5968038dfa8907e5984f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_toggle_features</b> (void)</td></tr>
<tr class="separator:aba6ebcd10ed5968038dfa8907e5984f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8200b62ee4a83450e3c5822e1d17f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a8200b62ee4a83450e3c5822e1d17f"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_read_registers</b> (uint8_t reg, uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a81a8200b62ee4a83450e3c5822e1d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55635ac13e46fc0c81b96d7b22562adf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55635ac13e46fc0c81b96d7b22562adf"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_read_register</b> (uint8_t reg)</td></tr>
<tr class="separator:a55635ac13e46fc0c81b96d7b22562adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1841af721caea30f46e6f16520084e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b1841af721caea30f46e6f16520084e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_read_pipes_addresses</b> (uint8_t *buf)</td></tr>
<tr class="separator:a4b1841af721caea30f46e6f16520084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c6290d3d3661d0c621946544a08faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c6290d3d3661d0c621946544a08faa"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_flush_rx</b> (void)</td></tr>
<tr class="separator:a72c6290d3d3661d0c621946544a08faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f433be78c5ad730df531210f21bdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a094f433be78c5ad730df531210f21bdf"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_flush_tx</b> (void)</td></tr>
<tr class="separator:a094f433be78c5ad730df531210f21bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728cc4983e2f3e3d496e044dcf8b649c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a728cc4983e2f3e3d496e044dcf8b649c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RF24_reset</b> (void)</td></tr>
<tr class="separator:a728cc4983e2f3e3d496e044dcf8b649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RF24 Fraise module declarations </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="adbe00719f3f835c82bd007081d040a7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CRC Length. How big (if any) of a CRC is included.</p>
<p>For use with setCRCLength() </p>

</div>
</div>
<a class="anchor" id="a82745de4aa1251b7561564b3ed1d6522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data rate. How fast data moves through the air.</p>
<p>For use with setDataRate() </p>

</div>
</div>
<a class="anchor" id="a1e4cd0bea93e6b43422855fb0120aace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="RF24_8h.html#a1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Power Amplifier level.</p>
<p>For use with setPALevel() </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a52e998916ce8974bbf027bf8630ed756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether there are bytes available to be read </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(radio.available()){</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  radio.read(&amp;data,sizeof(data));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>

</div>
</div>
<a class="anchor" id="a22baad441994f4ebc04d22f9a3a2900d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_closeReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether this is a real radio, or a mock shim for debugging. Setting either pin to 0xff is the way to indicate that this is not a real radio.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a legitimate radio Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe # to close, 0-5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0320af6c6bda86532f5654ef9e29f23d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_disableCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable CRC validation</p>
<dl class="section warning"><dt>Warning</dt><dd>CRC cannot be disabled if auto-ack/ESB is enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a509aba162cff1b2acf6d54753dc76b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_disableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable dynamically-sized payloads</p>
<p>This disables dynamic payloads on ALL pipes. Since Ack Payloads requires Dynamic Payloads, Ack Payloads are also disabled. If dynamic payloads are later re-enabled and ack payloads are desired then enableAckPayload() must be called again as well. </p>

</div>
</div>
<a class="anchor" id="a063ad3e74355a8754baa6ffc8fd74945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_enableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable custom payloads on the acknowledge packets</p>
<p>Ack payloads are a handy way to return data back to senders without manually changing the radio modes on both units.</p>
<dl class="section note"><dt>Note</dt><dd>Ack payloads are dynamic payloads. This only works on pipes 0&amp;1 by default. Call enableDynamicPayloads() to enable on all pipes. </dd></dl>

</div>
</div>
<a class="anchor" id="a3659b73ab3294bff2c24b37a1f29b596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_enableDynamicAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamic ACKs (single write multicast or unicast) for chosen messages</p>
<dl class="section note"><dt>Note</dt><dd>To enable full multicast or per-pipe multicast, use setAutoAck()</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This MUST be called prior to attempting single write NOACK calls <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;radio.enableDynamicAck();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;radio.write(&amp;data,32,1);  // Sends a payload with no acknowledgement requested</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;radio.write(&amp;data,32,0);  // Sends a payload using auto-retry/autoACK</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a546ea8db1d399bfcc14fa11d6d6dd377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_enableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamically-sized payloads</p>
<p>This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on ALL pipes. </p>

</div>
</div>
<a class="anchor" id="aa410f56bce0094054cb2bb2f001bc099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24_getChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get RF communication channel</p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured RF Channel </dd></dl>

</div>
</div>
<a class="anchor" id="ad34895106ece40c91131e95c654f821d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> RF24_getCRCLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CRC length <br />
CRC checking cannot be disabled if auto-ack is enabled </p><dl class="section return"><dt>Returns</dt><dd>RF24_CRC_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </dd></dl>

</div>
</div>
<a class="anchor" id="a4ff172256352b2208faa7a0d71dab27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> RF24_getDataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the transmission data rate</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hardware's currently configured datarate. The value is one of 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS, as defined in the rf24_datarate_e enum. </dd></dl>

</div>
</div>
<a class="anchor" id="a10df0046045b306fda76be78c2e5587a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24_getDynamicPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Dynamic Payload Size</p>
<p>For dynamic payloads, this pulls the size of the payload off the chip</p>
<dl class="section note"><dt>Note</dt><dd>Corrupt packets are now detected and flushed per the manufacturer. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(radio.available()){</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  if(radio.getDynamicPayloadSize() &lt; 1){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    // Corrupt payload has been flushed</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    return; </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  radio.read(&amp;data,sizeof(data));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Payload length of last-received dynamic payload </dd></dl>

</div>
</div>
<a class="anchor" id="acf354b84f44639e21c996ff503128597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24_getPALevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the current PA level.</p>
<p>NRF24L01: -18dBm, -12dBm, -6dBm and 0dBm SI24R1: -6dBm, 0dBm, 3dBm, 7dBm</p>
<dl class="section return"><dt>Returns</dt><dd>Returns values 0 to 3 representing the PA Level. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d310dca584ade306b224bd417a96bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24_getPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Static Payload Size</p>
<dl class="section see"><dt>See also</dt><dd>setPayloadSize()</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the payload </dd></dl>

</div>
</div>
<a class="anchor" id="a58f5e1a21ee319e8535fe2b4737fa7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver for nRF24L01(+) 2.4GHz Wireless Transceiver </p>

</div>
</div>
<a class="anchor" id="a9a75b9a7259269b5e5545c5ae9cbf10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_isAckPayloadAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if an ack payload was received in the most recent call to write(). The regular available() can also be used.</p>
<p>Call read() to retrieve the ack payload.</p>
<dl class="section return"><dt>Returns</dt><dd>True if an ack payload is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a13df844e485b64af029be27bff5bdf3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_isChipConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the chip is connected to the SPI bus </p>

</div>
</div>
<a class="anchor" id="ad9827d1b46e839e7df625b8697bb5c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_isPVariant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether the hardware is an nRF24L01+ or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the hardware is nRF24L01+ (or compatible) and false if its not. </dd></dl>

</div>
</div>
<a class="anchor" id="afcc6f30fd9aea9bc9e7ee60fbdd07280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_maskIRQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The radio will generate interrupt signals when a transmission is complete, a transmission fails, or a payload is received. This allows users to mask those interrupts to prevent them from generating a signal on the interrupt pin. Interrupts are enabled on the radio chip by default.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Mask all interrupts except the receive interrupt:</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;radio.maskIRQ(1,1,0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_ok</td><td>Mask transmission complete interrupts </td></tr>
    <tr><td class="paramname">tx_fail</td><td>Mask transmit failure interrupts </td></tr>
    <tr><td class="paramname">rx_ready</td><td>Mask payload received interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6ce99b2d6f1511eec7806516101428a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for reading</p>
<p>Up to 6 pipes can be open for reading at once. Open all the required reading pipes, and then call startListening().</p>
<dl class="section see"><dt>See also</dt><dd>openWritingPipe </dd>
<dd>
setAddressWidth</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pipes 0 and 1 will store a full 5-byte address. Pipes 2-5 will technically only store a single byte, borrowing up to 4 additional bytes from pipe #1 per the assigned address width. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the same address, except the first byte. Only the first byte in the array should be unique, e.g. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint8_t addresses[][6] = {&quot;1Node&quot;,&quot;2Node&quot;};</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;openReadingPipe(1,addresses[0]);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;openReadingPipe(2,addresses[1]);</div></div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then startListening(), it will overwrite the writing pipe. Ergo, do an openWritingPipe() again before write().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 24, 32 or 40 bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31d0a85f8f880cf821b953f93fef09d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Be sure to call openWritingPipe() first to set the destination of where to write to.</p>
<p>This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60-70ms.</p>
<p>The maximum size of data written is the fixed payload size, see getPayloadSize(). However, you can write less, and the remainder will just be filled with zeroes.</p>
<p>TX/RX/RT interrupt flags will be cleared every time write is called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;radio.stopListening();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;radio.write(&amp;data,sizeof(data));</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully and an ACK was received, or upon successfull transmission if auto-ack is disabled. New: Open a pipe for writing via byte array. Old addressing format retained for compatibility.</dd></dl>
<p>Only one writing pipe can be open at once, but you can change the address you'll write to. Call stopListening() first.</p>
<p>Addresses are assigned via a byte array, default is 5 byte address length</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint8_t addresses[][6] = {&quot;1Node&quot;,&quot;2Node&quot;};</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;radio.openWritingPipe(addresses[0]);</div></div><!-- fragment --> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint8_t address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;radio.openWritingPipe(address);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;address[0] = 0x33;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;radio.openReadingPipe(1,address);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>setAddressWidth</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the pipe to open. Coordinate these pipe addresses amongst nodes on the network. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa18075c80995cad33e4b829169613cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_pipeAvailable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there are bytes available to be read in the FIFO buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pipe_num</td><td>Which pipe has the payload available</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint8_t pipeNum;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if(radio.available(&amp;pipeNum)){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  radio.read(&amp;data,sizeof(data));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  Serial.print(&quot;Got data on pipe&quot;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Serial.println(pipeNum);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>

</div>
</div>
<a class="anchor" id="a27c1293a8ada1114bed1a76c9a044244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter low-power mode</p>
<p>To return to normal power mode, call powerUp().</p>
<dl class="section note"><dt>Note</dt><dd>After calling startListening(), a basic radio will consume about 13.5mA at max PA level. During active transmission, the radio will consume about 11.5mA, but this will be reduced to 26uA (.026mA) between sending. In full powerDown mode, the radio will consume approximately 900nA (.0009mA)</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;radio.powerDown();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;avr_enter_sleep_mode(); // Custom function to sleep the device</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;radio.powerUp();</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8228aa8163d5b7103f6bd70da3a67612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_powerUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave low-power mode - required for normal radio operation after calling powerDown()</p>
<p>To return to low power mode, call powerDown(). </p><dl class="section note"><dt>Note</dt><dd>This will take up to 5ms for maximum compatibility </dd></dl>

</div>
</div>
<a class="anchor" id="a11ee4d1091e2f5c8c5b434c24aa2a2d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the available payload</p>
<p>The size of data read is the fixed payload size, see getPayloadSize()</p>
<dl class="section note"><dt>Note</dt><dd>I specifically chose 'void*' as a data type to make it easier for beginners to use. No casting needed.</dd>
<dd>
No longer boolean. Use available to determine if packets are available. Interrupt flags are now cleared during reads instead of when calling available().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a buffer where the data should be written </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read into the buffer</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(radio.available()){</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  radio.read(&amp;data,sizeof(data));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>No return value. Use available(). </dd></dl>

</div>
</div>
<a class="anchor" id="a58e6af287baedc4fe1d40e6fc0716d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_reUseTX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-blocking write to the open writing pipe used for buffered writes</p>
<dl class="section note"><dt>Note</dt><dd>Optimization: This function now leaves the CE pin high, so the radio will remain in TX or STANDBY-II Mode until a txStandBy() command is issued. Can be used as an alternative to startWrite() if writing multiple payloads at once. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode with FIFO full for more than 4ms at a time. If the auto retransmit/autoAck is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing txStandBy() or ensure appropriate time between transmissions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write() </dd>
<dd>
writeFast() </dd>
<dd>
startWrite() </dd>
<dd>
writeBlocking()</dd></dl>
<p>For single noAck writes see: </p><dl class="section see"><dt>See also</dt><dd>enableDynamicAck() </dd>
<dd>
setAutoAck()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not Non-blocking write to the open writing pipe</dd></dl>
<p>Just like write(), but it returns immediately. To find out what happened to the send, catch the IRQ and then call whatHappened().</p>
<dl class="section see"><dt>See also</dt><dd>write() </dd>
<dd>
writeFast() </dd>
<dd>
startFastWrite() </dd>
<dd>
whatHappened()</dd></dl>
<p>For single noAck writes see: </p><dl class="section see"><dt>See also</dt><dd>enableDynamicAck() </dd>
<dd>
setAutoAck()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) This function is mainly used internally to take advantage of the auto payload re-use functionality of the chip, but can be beneficial to users as well.</td></tr>
  </table>
  </dd>
</dl>
<p>The function will instruct the radio to re-use the data in the FIFO buffers, and instructs the radio to re-send once the timeout limit has been reached. Used by writeFast and writeBlocking to initiate retries when a TX failure occurs. Retries are automatically initiated except with the standard write(). This way, data is not flushed from the buffer until switching between modes.</p>
<dl class="section note"><dt>Note</dt><dd>This is to be used AFTER auto-retry fails if wanting to resend using the built-in payload reuse features. After issuing reUseTX(), it will keep reending the same payload forever or until a payload is written to the FIFO, or a flush_tx command is given. </dd></dl>

</div>
</div>
<a class="anchor" id="a29d3f2e63e369890353fecdb42d28957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_rxFifoFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the radio needs to be read. Can be used to prevent data loss </p><dl class="section return"><dt>Returns</dt><dd>True if all three 32-byte radio buffers are full </dd></dl>

</div>
</div>
<a class="anchor" id="aef73522f85ff08814c701fce0b769ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setAddressWidth </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address width from 3 to 5 bytes (24, 32 or 40 bit)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_width</td><td>The address width to use: 3,4 or 5 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6181642ecced9289f503dcd4d2e0b85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setAutoAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets</p>
<p>This is enabled by default, so it's only needed if you want to turn it off for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a72a473f7fb7143b1805bbf08c2632d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setAutoAckPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets on a per pipeline basis.</p>
<p>AA is enabled by default, so it's only needed if you want to turn it off/on for some reason on a per pipeline basis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipeline to modify </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6934d62a152b8bf2ebc514ee2ec0ef92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set RF communication channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Which RF channel to communicate on, 0-125 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6338ec425b7f684915cd37488f3e5e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setCRCLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the CRC length <br />
CRC checking cannot be disabled if auto-ack is enabled </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a22d56451708fd802ea27de976b2df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the transmission data rate</p>
<dl class="section warning"><dt>Warning</dt><dd>setting RF24_250KBPS will fail for non-plus units</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a761beff12476b6dd967fe3128fdd5712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setPALevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Power Amplifier (PA) level to one of four levels: RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX</p>
<p>The power levels correspond to the following output levels respectively: NRF24L01: -18dBm, -12dBm,-6dBM, and 0dBm</p>
<p>SI24R1: -6dBm, 0dBm, 3dBM, and 7dBm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Desired PA level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a8d3765c21a8f230a379519edfe38aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Static Payload Size</p>
<p>This implementation uses a pre-stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to write().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba46e0c06d591e3e8fbe77bb30d7b65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_setRetries </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number and delay of retries upon failed submit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us. </td></tr>
    <tr><td class="paramname">count</td><td>How many retries before giving up, max 15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a795bb1fededae3d5e3d074653c662619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_startListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start listening on the pipes opened for reading.</p>
<ol type="1">
<li>Be sure to call openReadingPipe() first.</li>
<li>Do not call write() while in this mode, without first calling stopListening().</li>
<li>Call available() to check for incoming traffic, and read() to get it.</li>
</ol>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Open reading pipe 1 using address CCCECCCECC</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;byte address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;radio.openReadingPipe(1,address);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;radio.startListening();</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a42d9a6c41ffb1a516657b60c4e27602a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_stopListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop listening for incoming messages, and switch to transmit mode.</p>
<p>Do this before calling write(). </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;radio.stopListening();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;radio.write(&amp;data,sizeof(data));</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad12f4bcb9908f2d4efa0006145ba8691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_testCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the transmit buffer. This is generally not required in standard operation. May be required in specific cases after stopListening() , if operating at 250KBPS data rate.</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register Test whether there was a carrier on the line for the previous listening period.</dd></dl>
<p>Useful to check for interference on the current channel.</p>
<dl class="section return"><dt>Returns</dt><dd>true if was carrier, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="ad192ea1a3a815e1ef84fab39fa187618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_testRPD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. Valid only on nRF24L01P (+) hardware. On nRF24L01, use testCarrier().</p>
<p>Useful to check for interference on the current channel and channel hopping strategies.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;bool goodSignal = radio.testRPD();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if(radio.available()){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   Serial.println(goodSignal ? &quot;Strong signal &gt; 64dBm&quot; : &quot;Weak signal &lt; 64dBm&quot; );</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   radio.read(0,0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>true if signal =&gt; -64dBm, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="ac3502954f448fb04e566bd727b32c4eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_txStandBy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called as soon as transmission is finished to drop the radio back to STANDBY-I mode. If not issued, the radio will remain in STANDBY-II mode which, per the data sheet, is not a recommended operating mode.</p>
<dl class="section note"><dt>Note</dt><dd>When transmitting data in rapid succession, it is still recommended by the manufacturer to drop the radio out of TX or STANDBY-II mode if there is time enough between sends for the FIFOs to empty. This is not required if auto-ack is enabled.</dd></dl>
<p>Relies on built-in auto retry functionality.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Example (Partial blocking):</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        radio.writeFast(&amp;buf,32);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        radio.writeFast(&amp;buf,32);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        radio.writeFast(&amp;buf,32);  //Fills the FIFO buffers up</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        bool ok = txStandBy();     //Returns 0 if failed. 1 if success.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                                   //Blocks only until MAX_RT timeout or success. Data flushed on fail.</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>txStandBy(unsigned long timeout) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if transmission is successful </dd></dl>

</div>
</div>
<a class="anchor" id="a36aad17af719b63e7f80915de9ab5288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_whatHappened </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this when you get an interrupt to find out why</p>
<p>Tells you what caused the interrupt, and clears the state of interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_ok</td><td>The send was successful (TX_DS) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_fail</td><td>The send failed, too many retries (MAX_RT) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_ready</td><td>There is a message waiting to be read (RX_DS) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6badb9c1062591a6b89171c7116571be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24_write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write for single NOACK writes. Optionally disables acknowledgements/autoretries for a single write.</p>
<dl class="section note"><dt>Note</dt><dd>enableDynamicAck() must be called to enable this feature</dd></dl>
<p>Can be used with enableAckPayload() to request a response </p><dl class="section see"><dt>See also</dt><dd>enableDynamicAck() </dd>
<dd>
setAutoAck() </dd>
<dd>
write()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0), NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa68e730561ea861392e55329049a6a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24_writeAckPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an ack payload for the specified pipe</p>
<p>The next time a message is received on <code>pipe</code>, the data in <code>buf</code> will be sent back in the acknowledgement. </p><dl class="section see"><dt>See also</dt><dd>enableAckPayload() </dd>
<dd>
enableDynamicPayloads() </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only three of these can be pending at any time as there are only 3 FIFO buffers.<br />
 Dynamic payloads must be enabled. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Ack payloads are handled automatically by the radio chip when a payload is received. Users should generally write an ack payload as soon as startListening() is called, so one is available when a regular payload is received. </dd>
<dd>
Ack payloads are dynamic payloads. This only works on pipes 0&amp;1 by default. Call enableDynamicPayloads() to enable on all pipes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe# (typically 1-5) will get this response. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data that is sent </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data to send, up to 32 bytes max. Not affected by the static payload set by setPayloadSize(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3a484c40aa7004084ac2b6e864353004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24_csDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On all devices but Linux and ATTiny, a small delay is added to the CSN toggling function</p>
<p>This is intended to minimise the speed of SPI polling due to radio commands</p>
<p>If using interrupts or timed requests, this can be set to 0 Default:5 </p>

</div>
</div>
<a class="anchor" id="a28971efbe44f8b4dd531452cf696b8e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24_txDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The driver will delay for this duration when stopListening() is called</p>
<p>When responding to payloads, faster devices like ARM(RPi) are much faster than Arduino:</p><ol type="1">
<li>Arduino sends data to RPi, switches to RX mode</li>
<li>The RPi receives the data, switches to TX mode and sends before the Arduino radio is in RX mode</li>
<li>If AutoACK is disabled, this can be set as low as 0. If AA/ESB enabled, set to 100uS minimum on RPi</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>If set to 0, ensure 130uS delay after stopListening() and before any sends </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ae00123db5b5581e05182e53ab3951bf.html">RF24</a></li><li class="navelem"><a class="el" href="RF24_8h.html">RF24.h</a></li>
    <li class="footer">Generated on Tue Nov 14 2023 12:13:49 for Fraise by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
